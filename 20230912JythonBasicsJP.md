# Jythonの基礎

三浦耕太

last update:2023.09.12 「ImageJではじめる生物画像解析」のサポートサイトに掲載した解説をアップデートして、GitHubに移植しました。なお、この解説は2012年頃の「少数性生物学」のワークショップに向けて用意した講習が最初のバージョンになります。機会を作っていただいた大阪大学の永井さんにここでお礼を申し上げます。

## 序論

ImageJには独自のマクロ言語が実装されており、多くの作業はマクロで記述可能である。とはいえImageJのマクロはGUIを経由したスクリプトであるため、ヘッドレス（GUIなし）で使用する際にはさまざまな制限が生じる。また、マクロの関数が用意されていないプラグインを使う場合などに不自由を感じることがある。これらの問題があるときにはJavaの仕様（APIと呼ばれる）に直接アクセスできるスクリプト言語を使う必要がある。

ImageJにおけるスクリプティング言語としては他にGroovy、Jython (Javaで実装したPython)、Javascript(Rhino)、BeanShellなどがある。処理速度を高めたいならば、ClojureもしくはScalaを使うが、2023年現在、これらを使っている人は稀である。型を正確に記述したいならGroovyがお勧めである。JavascriptはFijiではなくともImageJでそのまま使うことが出来る。また、Javascriptはコマンドレコーダの記録言語としても実装されており、マクロと同じように記述することができる。ただしこの場合の運用は、マクロと同程度の機能に限られるので、Javadocを駆使しながらコーディングを行うのでないならば（Javadocについては後述する）マクロでプログラムを書くことをお勧めする。

JythonはPythonの文法であること、Jython自体に実装されているPython由来のさまざまな便利な機能があることから（特に文字列操作、ファイルシステムへのIOにおいてさまざまなメリットがある）、Jythonを使う研究者が多い。ImageJではJythonのファイルを実行した時にJythonのライブラリが存在しないことがわかると、ImageJはJythonのライブラリを自動的にダウンロードする。Fijiでは最初からJythonが導入されている。以下ではFijiを使っていることを前提に説明をすすめる。理由は、コードを書いて実行する上できわめて優れた機能をもつエディタ（Script Editor）がFijiには付属しているからである。

今回はJythonによるスクリプティングを学ぶ。ImageJのさまざまなクラス群（ImageJはそれぞれ特定の機能をもつJavaでプログラムされたクラスが複数集まった存在であると考えると良い）を扱うには、クラス群の諸機能を参照するためのレファレンスが必要になる。Javadocと呼ばれる仕様書（ImageJの場合にはImageJのJavadoc）がこれにあたり、プログラミングの基本を習得したあとはJavadocを繰りながらスクリプトを書くことになる。ImageJのJavadocは次のリンク先にある。Javadocを読み解くには一定の知識が必要になるが、これは実際のコードを書き、実行しながら、少しずつ学んでいけるようにするつもりである。

[http://imagej.net/developer/api/](http://www.google.com/url?q=http%3A%2F%2Fimagej.net%2Fdeveloper%2Fapi%2F&sa=D&sntz=1&usg=AOvVaw1v6xdkr40Dui8Lv76D9sT6)



## 参照になるページ


英語になるが、Jythonそのものに関しては、

[http://www.jython.org/docs/](http://www.google.com/url?q=http%3A%2F%2Fwww.jython.org%2Fdocs%2F&sa=D&sntz=1&usg=AOvVaw3mLlFXdO7x8rPz35Vugi97)

以下のリンクは、今後JythonでImageJ/Fijiのスクリプティングを行う際に参考になるページである。

[Jython Tutorial @ Fiji wiki](http://www.google.com/url?q=http%3A%2F%2Ffiji.sc%2FJython_Scripting&sa=D&sntz=1&usg=AOvVaw0hyXpOOw3wjHeyOgalMko_)

[Jython Cookbook @ CMCI](http://www.google.com/url?q=http%3A%2F%2Fcmci.embl.de%2Fdocuments%2F120206pyip_cooking%2Fpython_imagej_cookbook&sa=D&sntz=1&usg=AOvVaw0mt6Zji4Yk15in4EC3UmjP)

## はじめの一歩

### スクリプトエディタの使い方

スクリプトエディタ(Script Editor)はFijiのメニューで

\[File > New > Script...\]

を選ぶことで開始できる。

スクリプトエディタには独自のメニューがついている。そのうちの一つが'language'であり、この項目をクリックして、'Python'を選ぶことで、Jythonのコマンドを解釈させることができるようになる。

エディタの右側は上下ふたつのパネルにわかれており、上がスクリプトを入力するテキストフィールドのパネル（図1A）、下が出力フィールドのパネルになっている（図1B）。左のサイドバーは、よく使うフォルダなどを登録することができるファイルへのアクセスのためのパネルになっている(図1C)。右の上下のパネルの間にはRunボタンが左側に（図1-1）、右側にはStdout（通常の出力、図1-5）とStderr（エラー出力）の二種を切り替えるボタンがある。デフォルトでは通常の出力が表示される。なお、英文になるが、[Script Editorの機能を詳しく解説した拙文があるので、興味のある方はそちらを参照](https://www.google.com/url?q=https%3A%2F%2Fanalyticalscience.wiley.com%2Fdo%2F10.1002%2Fwas.000400045&sa=D&sntz=1&usg=AOvVaw2kl56H_AZ7lNX7Gl8KfYU8)に。）

![fig1_annotatedEditor](fig/fig1_annotatedEditor.png)

図１　スクリプトエディターの構成。



### Hello World

スクリプトエディタのテキストフィールド（図1A）に以下のように入力する。
```python
print("Hello World!")
```
左下にある'Run'ボタンをクリックすると、下側の出力フィールドに
```python
Hello World!
```
と表示されるはずである。この場合、出力先はスクリプトエディタである。`print`はJythonのコマンドであり、そのあとのカッコの中の文字列ないしは数字を通常出力先（Stdout）出力せよ、というコマンドである。

出力先をImageJのログウィンドウにしたい場合は
```python
from ij import IJ
IJ.log("Hello World!")
```
とする。先程の`print`の場合とことなり、`IJ.log`というコマンドのあとに出力される文字が括弧で囲まれている。IJ.logというコマンドについての詳細は後述する。また、最初に`from x import y`という一行があるが、これは日本語で「インポート文」としばしばよばれる。IJ.logというコマンドを使えるように明示的に「輸入＝import」するのがこの行である。これについてもあとで詳しく述べる。

さらにコマンドを付け加えてみよう。
```python
from ij import IJ
IJ.log("Hello World!")
IJ.log("\\Clear")
```
なおバックスラッシュ(`\`)は日本語のOS環境では、円記号（`¥`）として表示される。機能的には同等の役割を果たす。

この3行のコードを実行（Runをクリックすること）すると、ログウィンドウにはなにも表示されない。2行目と3行目を入れ替えてみる。

```python
from ij import IJ
IJ.log("\\\Clear")
IJ.log("Hello World!")
```

この場合には、`Hello World`が表示される。`\\\Clear`は最初にバックスラッシュが２つ連続して存在することによって、テキストそのものではなく、一種のコマンドを意味することになる（\\\はエスケープシークエンスと呼ばれる）。`\\\Clear`はログウィンドウをクリアしてまっさらにせよ、というコマンドである。

上の3行のコマンドの２つの例における出力の差がプログラミングの本質である。すなわち、コマンドは上から下にむかって次々に実行される。したがってどのような順番でコマンドが書かれているか、ということが出力の内容を決定する。

ここまで説明して、「`IJ`はインポートしたのに、`print`はインポートしないのか」と思われる方もいるかもしれない。なぜインポートしないのか、というと、`print`は組み込み関数といって、わざわざインポートしなくても最初から使えるようになっている。その意味では`from`や`import`も組み込み関数であるが、この場合は特に「関数 function」ではなく「宣言 declaration」と呼ばれる。

### 変数の扱い
さて、次の一行を入力して実行してみよう。
```python
print(1 + 2)
```

出力パネルに
```
3
```
と表示されるはずである。これは、`print`コマンドに続くカッコの中の数式を、数字として計算した後にその結果がプリントされている。次のように書き換えて実行してみよう。
```python
a = 1
b = 2
c = a + b
print(c)
```
出力パネルには先ほどと同じく`３`が表示されるはずである。ただしこの場合、最初に変数`a`に1が代入され、次に`b`に2が代入され、３行目ではこれらの変数を使って加算が行われその結果が変数`c`に代入されている。最後の行ではこの変数`c`がコマンド`print`に渡されて、`c`が保持している値が出力される。

**演習**：`a`の値、`b`の値を別の数に変えて、出力結果が変わることを確かめよ。

以上は数字である。変数には数字ではなく、文字列を代入することもできる。
``` python
a = "Hello"
b = " World"
c = a + b
print(c)
```
出力は`Hello World`となっているはずである。ここで注意して欲しいのは三行目の“数式”である。ここではプラスのサインが`a`と`b`の間にあるが、起こることは算数の足し算ではない。`a`の文字列の後に`b`が追加される(concatenateという)。`Hello`と`world`の数学的な足し算がなにを結果するのかはわからないが、普通そのような足し算はしない。そこで、スクリプトを解釈しているJythonインタプリタ（解釈機能）は、変数が保持している値が数字であるか文字列であるかを分別してプラスサインがなにを実行するのかを切り替えていることがわかる。

文字列であることは、ダブルクオートで文字を囲むことによって明示している。このことから次のようなこともできる。
```python
a = "1"
b = "2"
c = a + b
print(c)
```
この出力結果は
```
12
```
となる。なぜならば、数字の1と2がそれぞれダブルクォートで囲まれているため、ナマの数字ではなく文字列の数字として変数に格納されることになるから、三行目のプラスサインは算数ではなく文字列の追加として機能することになるからである。なお、文字列を囲むのはダブルクオートではなくシングルクオート（` ' `）であっても機能する。

さて、少々ここから発展させる。変数には、数字や文字列のみならず、画像などのより複雑な形式のオブジェクトを代入し、そのオブジェクトを保持させることができる（オブジェクトは文字通り「モノ」とおもっていただければよい。あるいは「ブツ」でもよい）。たとえば、であるが、
```python
from ij import IJ
imp = IJ.openImage('/Users/miura/image.tif')
```
としたときには、impという変数に画像が与えられている。impを画像だ、と思って以降のスクリプトをしたためることになる。たとえばこれに続き
```python
imp.show()
```
と次の行に書くと、画像がデスクトップに表示されることになる。`IJ.openImage`は、画像ファイルを読み込むためのコマンド、その引数（ひきすう、と読む。括弧内の文字）はファイルの絶対パスの文字列である。また、`imp.show()`は、変数`imp`に画像が与えられているため、**画像に付随するコマンド`show()`を実行せよ**、ということであると理解してもらえればよい。よりプログラミングの世界の言葉遣いでいうとこれは、「**画像オブジェクトのメソッド`show()`を実行せよ**」という説明になる。**「メソッド」はいわば関数**、と考えればよい。以降、メソッドという言葉を使うが、関数と考えていただいて差し支えない。なぜわざわざメソッドという言葉を使うのか、そのより詳しい話は後ほど詳述する。

また、絶対パス、とは、パソコンの中のその場所にそのファイルがあるかを示す住所のようなものである。パソコンを使っている人ならだれでも、ファイルがツリー上に構成されたフォルダの中のどこかにファイルを保存することを行なっているだろう。この場所がどこであるのかを示すのが絶対パスである。上の例`/Users/miura/image.tif`では、Usersフォルダの中のmiuraフォルダの中にimage.tifというファイルがあることを示している。スラッシュ`/`はパスセパレータと呼ばれ、フィルダの階層構造を上位から下位に向かってフォルダの名前ごとに区切る役割を果たしている。

なお、ウィンドウズにおけるパスの表記は若干ことなっている。たとえば`c:\\Users\\miura\\image.tif`は、CドライブのUsersフォルダの中のmiuraフォルダの中にimage.tifがあることを示している。この場合、パスセパレータは、2つのバックスラッシュが担っている。

絶対パスとは別に相対パスという住所の表記法もある。はがきを送るのに郵便番号から始まる住所を書くが、家族に配達してもらうならば「二ブロック先を右に、三軒目の鈴木さん」という今いる場所から相対的に送り先を指定する宛名の書き方も可能だろう。ファイルのありかを書くのに「今いるフォルダから2つ上に上がってその下にあるGというフォルダの下のimage.tif」という表記も可能である。これを相対パスという。相対パスは、フォルダの上位構造が全く異なっていてもあるプロジェクトのフォルダの内部構造が同一であればそのプロジェクトのフォルダがどこに存在しているか関係がなくなる。プロジェクトのフォルダをあちらこちらに移動できるので便利である…のだが、今回は使わないので具体例は割愛する。

### リスト

ある数列をひとつのリストとしてまとめておくことが可能である。たとえば
```python
aa = [1, 3, 5, 17, 25]
```
とすると、aaは要素を５つもつリストとなる。個別の要素を取り出すには、リストを格納している変数（上の場合は`aa`）に続けてブラケットで要素のインデックスを指定する。インデックスはゼロから始まる。上の例で３番目の要素を取り出したければ、インデックスは２になる。上の行につづけて
```python
print(aa[2])
```
とすると、５と出力されるはずである。すべての要素を出力したい場合、
```python
print(aa)
```
とすれば、リストがそのまま出力されるだろう。

**演習** 存在しないインデックスを指定して出力しようとすると、エラーが出ることを確認せよ。エラーを解読し、理解せよ。

### リストの生成 range()

上の例では、数字を直接指定してリストを作った。他にも、パターンを数列をリストとして生成することができる。次のようにする。
```python
bb = range(10)
print(bb)
```
とすると、出力には
```
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```
と出るはずである。`range(10)`は、0から1づつ数えて10個より少ない整数の数列をリストとして生成せよ、というコマンドになる。

引数がひとつだけすなわち`range(n)`の場合、`0 <= k < n` の`ｋ`が生成される。つねに0から始まる。最初の数字を0ではなく任意のものに変えるには、引数をふたつにする。
```python
print( range(5, 10) )
```
を実行すると
```
[5, 6, 7, 8, 9]
```
と出力されるだろう。`range(n1, n2)`によって、n1 <= k < n2の整数kのリストが生成される。これまでの場合、数字の間隔はかならず1であったが、この間隔（ステップサイズという）も引数を3個にすると三番目の引数として指定できる。
```python
print( range(0, 10, 2) )
```
出力は
```
[0, 2, 4, 6, 8]
```
となるはずである。

### リストの長さ len()

リストの長さはさまざまである。長さを知るためにはlenという関数を使う。
```python
print( len(aa) )
print( 'list length:', len(aa))
```
この一行目は単に数字の５を出力するだろう。他にも`print( len(range(5)) )`などを試してみるとよい。二行目は付け足しであるがこの数字がなにかを示すために、最初に`list length:` という文字列を加えた。`print`に与える引数はコンマで区切ればいくつでも可能である。出力先ではコンマの位置に自動的にスペースが挿入される。

###  リストは数に限らない

ここまで紹介したリストは数のリストであった。とはいえ、リストの内容は数に限られない。たとえば、画像もリストに含めることができる。ここでは複数のチャネルを持つ一つの画像データを、それぞれのチャネルの画像のリストに変換してみよう。

[File > Open Samples > Hela Cells (1.3M, 48-bit RGB)]

によって3つのチャネルをもつ画像を開いて欲しい。次のスクリプトを書いてHela細胞の画像に関して実行する。
```python
imp = IJ.getImage()
imps = ChannelSplitter.split(imp)
print( len(imps) )
imps[0].show()
imps[1].show()
imps[2].show()
```
一行目は、現在アクティブな画像（デスクトップ上に開いている画像である。複数ある場合は、１番上にある画像がアクティブな画像である）を変数`imp`として得ている。二行目ではこの画像の各チャネルの画像を、`imps`というリストとして取得している。このリストは、数字ではなく画像を要素として保持しているリストの例である。三行目ではそのリストの長さを出力する（3と出力されているはずである）。4行目から6行目では、それぞれのチャネルの画像を個別に表示している。リストの一番目の要素が赤のチャネル、二番目の要素が緑のチャネル、3番目の要素が青のチャネルである。

## ループ

リストの要素をそれぞれ独立に出力するにはつぎのようにする。
```python
aa = range(5)
for a in aa:
	print( a )
```
すこしでもプログラミングをかじったことのある人ならば、「ああ、`for`をつかったループですね」と思うかもしれないが、知らない方々のために解説すると、上の一行目はすでに学んだように、`0 <= k < 5`の数列をリストとして生成している。次の行の`for`ではじまる部分は、

*リストaaの各要素を変数aに順番に代入せよ、そして、要素ひとつ毎にその下に連なる行頭を字下げしたコードを実行せよ。*

という意味である。この例の場合、繰り返し実行されるのは字下げした三行目であり、`a`の内容を出力する。全体としてみれば`aa`の要素が順繰りに出力されることになる。この場合一行だけだが、さらに同じように字下げしたコードがもし続くならば、それらもくりかえし実行される。例えば
```python
aa = range(5)
for a in aa:
	print( a )
	print( a*5 )
```
のようにすれば、ループ毎に二行出力されることになる。

上の場合は、`range`によって整数のリストを作成し、それでループを行っているが、リストであればその構成要素がなんであってもループさせることができる（プログラミングを知っているひとならばイテラブルなオブジェクト、といえばすぐにわかるかもしれない）。たとえば前項で扱った3チャンネル画像を分割して表示するスクリプトをforを使って書きなおしてみよう。
```python
imp = IJ.getImage()
imps = ChannelSplitter.split(imp)
print len(imps)
for aimp in imps:
	aimp.show()
```
`imps`は`ImagePlus`オブジェクトのリストである。したがってこれはそのまま`for`ループに供することが可能であり、ループ毎に変数`aimp`に要素が代入される。そしてループ毎に1番目のチャネルから3番目のチャネルまでが表示されるのである。

ImageJマクロ、ないしはCなどのプログラミングに慣れている人はおそらく次のような疑問にすぐに突き当たるだろう：　整数ではないリストをループさせるとき、インデックスを得たい場合にはどうすればよいのか？

ふたつの解決方法がある。ひとつはインデックスでループを回す方法である。上のコードを書き換えてみよう。
```python
imp = IJ.getImage()
imps = ChannelSplitter.split(imp)
print len(imps)
for i in range(len(imps)):
	print( "channel", i )
	imps[i].show()
```
もうひとつの方法は、`enumerate`を使う方法である。こちらのほうがPythonらしい使い方である。
```python
imp = IJ.getImage()
imps = ChannelSplitter.split(imp)
print len(imps)
for i, aimp in enumerate(imps):
	print( "channel", i )
	aimp.show()
```
注目して欲しいのは`for`の構文で返り値の変数が2つ、`i`	と`aimp`になっていることである。iにはループのインデックスが入り、aimpにはリストimpsの要素が入る。

### 条件
変数やその状態を判別して、その状況に応じてなんらかの処理を行う、といったことをしたいときには、if ではじまる判定式を使う。具体的には次のようなことだ。
```python
a = 5
if a == 5:
	print( a )
```
実行すると`5`という数字が出力されるだけであるが、これは二行目において、`a`が`5`であることを判定し、正しいことを確認した上で`a`が出力される。

この2行目は等号を2つ連ねた書き方をしている。これは真偽(True or False)を判定するための式で、たとえば次のような短いコードを書いてみよう。
```python
a = 5
print( a==5 )
```
出力されるのは`True`である。一行目を`a = 10`と書き換えると、出力は`False`になるはずである。すなわち、`a==5`と書くことで"aは5か？"という疑問に真偽で解答するという形になっている。このことがわかれば次の（あまり意味がないが理解の助けにはなる）コードが理解できるだろう。
```python
a = 5 if True:
print( a )
```
この場合、二行目に意味はない。なぜならば判定式がなくつねに`True`だからである。したがってこれは
```python
a = 5
print( a )
```
というコードと変わらない。また
```python
a = 5
if False:
	print( a )
```
であれば、`a`がなんであってもなにも出力しない。これらを理解できれば
```python
a = 10
if a == 5:
	print( a )
```
の場合にはなにも起きないことは簡単に想像つくであろう。判定式が偽なので字下げの部分は実行されないのである。偽の場合にもなにか行うようにするには`else`を使う。
```python
a = 10
if a == 5:
	print( "a is 5" )
else:
	print( "a is not 5" )
```
のように、	`else`によって付け加える。応用問題になるが
```python
a = 10
if False:
	print( "a is 5" )
else:
	print( "a is not 5" )
```
の場合にはどうなるか？常に"a is not 5"という出力がおきる。

より実際的な`if`の例を次にみてみよう。
```python
filename = "image.tif"
if filename.endswith(".tif"):
	print( "This file is a tiff file" )
```
この場合、判定式はコマンドそのもので、文字列`filename`が".tif"で終わっている、ということが真であるか偽であるかを判定するメソッドである。文字列を判定する上でのより親切な解説はたとえば、以下を参照にするとよいだろう。

[Pythonで文字列を比較（完全一致、部分一致、大小関係など）](https://note.nkmk.me/python-str-compare/)

`endsWith`とともにさまざまなメソッドを文字列に対して処理することができるのがわかるだろう（なお、Python2.5を参照にすれば、Jythonで実装されている機能と同じである）。Jythonにも英語の解説はあるが（例えば[ここ]()）、こうした特に基礎的な部分の解説はPythonのものが充実しており、ほぼそのまま使える。ただし、Jythonの文法はPython2.0時代のままでとどまっているので、Python3.0が主流になった今では、使えない機能もあることは留意しておくとよい。

なお、文字列に関するJythonの本家の解説は以下にある。

[Strings and String Methods](https://jython.readthedocs.io/en/latest/DataTypes/#strings-and-string-methods)

掲げられた表2-2に、文字列（String）が使えるさまざまなメソッドがリストされているのがわかるだろう。例えば、表の１番最初にある`capitalize()`メソッドを試しに使ってみれば、上のコードを若干書き換えて次のように試すことができる。

```python
f = "image.tif"
cf = f.capitalize()
print(cf)
```

これを実行すると`Image.tif`と最初の文字が大文字になることがわかるだろう。

**演習：**上記リンク先の表2-2から、文字列で使えるメッソドを探し、上のコードを"image"だけ出力するように改造せよ。

<!--f = "image.tif"
cf = f.rstrip(".tif")
print(cf)
-->

##  オブジェクトとインスタンス化

以上で基本的な使い方を解説したが、ここでおそらく、プログラミングの経験があまりない方には、あるいはこれまでプログラミングというとImageJマクロしか使ってこなかった方には耳慣れない言葉や概念を紹介することにする。これは、ImageJをライブラリとして使うには必須の知識でもあるが、習うより慣れろ、ということで実例を上げながら解説するので、実際にコードを試しながら進んでほしい。

我々が扱うのは主に画像であるが、ImageJではそれぞれの画像を「オブジェクト」として扱う。「オブジェクト」は日本語に直訳すれば「モノ」「物体」「対象」であるが、プログラミングの世界では実在するモノというよりも、コンピューターのメモリ上に保持されるデータのことを「オブジェクト」という。モニターに表示される画像もまた「オブジェクト」である。

もちろん、ハードディスクに保存された画像もデータなのであるが、このデータをImageJの世界で扱えるような形で読み込んでさまざまな処理を行うことができるようにしたデータの状態を、「ImageJの画像オブジェクト」あるいは単に「画像オブジェクト」と呼ぶことにしよう。なぜ単に「画像」と呼ばないかというと、「画像」ではあまりに一般的すぎるので、多義的だからである。ここでは、どうやってImageJで画像が扱われているのか、ということを知るために、このようにより特定の概念と言葉を導入している。

実は、ImageJの画像オブジェクトには、固有の名前がついており、「ImagePlusオブジェクト」という。固有名はなんでもいいのであるが、Wayne Rasbandが最初にImageJを作り始めたときに、そのような名前を与えたから、そのような名前になっている。では、ImagePlusオブジェクトを作ってみよう。
```python
from ij import ImagePlus
imp = ImagePlus( "/Users/miura/blobs.tif" )
imp.show()
```
これはIJというグループの中のlogという関数を使っている、と考えると良い。このIJグループは、使うことを明示してからでないと使うことができないので、最初の行の`from ij import IJ`という行が加えられている。`from xx import yy`はいわば、「xxパッケージからyyグループを輸入」を意味しており、

ImagePlusというのは固有名ではあるのだが、実際の解析の現場では、一番最初に撮った画像、２番目に撮った画像、というように、複数の画像を扱うことがあたりまえである。いずれの画像も、ファイルからImageJに読み込んだときには画像オブジェクト＝ImagePlusオブジェクトになるわけであるが、これらの画像は同じオブジェクトではなく、ことなる画像のオブジェクトである。ただし、ImagePlusという名前は同じである。ややこしいかもしれないが、詳しいことをいうと、２つのオブジェクトにはそれぞれ異なるID番号がついていて、ID1のImagePlusオブジェクト、ID2のImagePlusオブジェクト、という形で識別される別のオブジェクトである。しかしながら、ImagePlusという形式はいずれも保持している。この一般的な形式を「クラス」という。「クラス」は、いわば役所で渡される書式のようなものであって、書くべき項目は同一であるが、その渡された人々が空欄に書くことは違う、と考えたらよいかもしれない。だいたい、これで理解はよいのだが、この書式は紙の書式とは大いにことなっており、さまざまな関数も保持している。

例えば、その書式の生年月日のところに西暦で生年を書いたとしよう。普通の紙の書式であれば、西暦のままであるが、たとえばこの書式にエクセルの関数のように、自動的に年号に換算する機能が付属していたとする。すると、西暦で書くと、その関数が自動的に適用され、右側のカッコに「平成XX年」などと、文字が浮き上がる仕組みがあるとする。そんな便利な紙が世の中に実現するかどうかは知らないが、そうした、なんらかの機能、すなわち関数を持つのが、この特別な想像上の書式、つまりクラスなのである。

説明が少々長くなってしまったが、早速、ImagePlusオブジェクトを作ってみよう。つまり画像をよみこむことなのだが、これはすでに最初の方で行った次のコード
```python
imp = IJ.openImage('/Users/miura/image.tif')
```
でもよいのだが、せっかくなのでImagePlusであることをより強調して


静的メソッド

IJクラスのメソッドはほとんどが「静的」である。これは、クラスをインスタンス化しなくても、そのメソッドを使えることを意味している。インスタンス化とは、いわばそのクラスのスペックを鋳型とするクローンを作ることを意味しており、いくつも似たようなクローンを作ることができる。たとえば、ImageJでは、画像はすべてImagePlusというクラスのインスタンスである。ことなる画像であっても、同じクラスに属している、ということである。画像の大きさはことなっていいても、幅と高さという属性をいずれも所持しており、こうした点において「同じクラス」なのである。

[未完] Javadocの使い方

## ファイルシステムへのアクセス

さて、ファイルシステムにアクセスしてファイルの名前のリストを取得してみよう。いくつもの方法があるが、ここではJythonに実装されている`os`パッケージの`os.walk`関数を使う。少々長くなるが、コードの下に続く解説を読んでほしい。
```python
srcDir = DirectoryChooser("please select a folder").getDirectory()
IJ.log("directory: "+srcDir)
for root, directories, filenames in os.walk(srcDir):
	for filename in filenames:
		if filename.endswith(".tif"):
			path = os.path.join(root, filename)
			IJ.log(path)
			imp = IJ.openImage(path)
			imp.show()
			#imp.close()
```
**コードの解説**

一行目に登場する`DirectoryChooser`はImageJのクラスである。ここでは`DirectoryChooser`のインスタンス化と、そのメソッドの使用を一行で行なっていることに注意しよう。これは、次のように２行にわけて書くこともできる。

```
dc = DirectoryChooser("please select a folder")
srcDir = dc.getDirectory()
```

一行目ではクラス`DirectoryChooser`のコンストラクタによるインスタンス化を行い、そのそのことで生成したオブジェクトを変数`dc`に代入する。二行目では、クラス`DirectoryChooser`のメソッドである`getDirectory()`を実行し、対象となるフォルダのパスをインタラクティブに取得する。元のコードの一行目では、この２つのステップが一行でなされている。コンストラクタによるインスタンス化とメッソッドの実行を一行で書いてしまう書き方はスクリプティング的である。Javaではこのようなことができない。

`os.walk`の結果を`for`ループで展開するのは、ディレクトリを再帰的に探索するためである。

### IJクラス -静的メソッド

IJクラスには静的（Static, スタティック）なメソッドが多くリストされている。クラスとは、機能（メソッドと呼ばれる）や変数（フィールドと呼ばれる）をまとめたひとつのまとまりである。たとえば
```python
IJ.beep()
```
は、IJクラスの中のひとつのメッソッドが`beep()`であり、これを実行すると音がなる。



### コマンドレコーダ

`IJ.run()`メソッドは、メニューの項目を指定して実行する。二番目の引数であるオプションは、通常であればダイアログボックスで入力する内容を指定する。

###  ImagePlusクラス

`ImagePlus`は画像そのものと画像の属性（スケールやmultitiff）などを含むクラスである。デスクトップに開いた画像オブジェクトをグラブする際にも`ImagePlus`のオブジェクトを取得することになる。またこれは慣例的なことであるが、変数は`imp`とすることが多い。
```python
imp = IJ.getImage()
frames = imp.getStackSize()
IJ.run("Set Measurements...", " mean redirect=None decimal=3")
IJ.run("Clear Results")
for i in range(frames):
	imp.setSlice(i + 1)
	IJ.run("Measure")
```
このコードはデスクトップ上に開いているスタックを画像オブジェクト`imp`としてグラブし、そのスライスを一枚一枚めくりながら測定を行う。

### ImageProcessorクラス

`ImageProcessor`は、`ImagePlus`の属性の一部であり、画像そのもののクラスである。さまざまな画像処理のアルゴリズムをメソッドとして所持している。実際にフィルタをかけたりするのはこのクラスのオブジェクトで行う。スタック画像の場合、`ImagePlus`のオブジェクトの中に複数の`ImageProcessor`オブジェクトが入っている、とかんがえるとよいだろう。

### 輝度プロファイルの例

輝度プロファイルを得る場合には`ProfilePlot`クラスをインスタンス化する必要がある。このインスタンス化の際に、現在トップにある画像を指定すれば、そのまま輝度プロファイルを取得することができる。
```python
imp = IJ.getImage()
pf = ProfilePlot(imp)
profile = pf.getProfile()
for val in profile:
	print val
```
このスクリプトの結果をさらにCSVに出力してみる。Jythonの`csv`パッケージが簡便なのでそれを使おう。
```python
import csv
imp = IJ.getImage()
pf = ProfilePlot(imp)
profile = pf.getProfile()
for val in profile:
	print val
	
f = open('/Users/miura/Desktop/prof.csv', 'wb')
writer = csv.writer(f)
for index, val in enumerate(profile):
	writer.writerow(\[index, val\])
	
f.close()
```
標準でロードされないパッケージは、上記のように`import`で明示的にロードする必要がある。ImageJのクラスもおなじように`import文で宣言する必要がある。

<!-- fiji test.py ないしは jython test.py

といった使い方をする場合には、インポート文を加えておく必要があるので要注意である。
-->
このサイトのすべての記事の著作権は著者に帰属します。